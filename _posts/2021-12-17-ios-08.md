---
title: "UIkit Basic 7 (URLSession, HTTP, API 통신)"
excerpt: "UIkit Basic"

categories:
  - uikit

toc: true
toc_sticky: true
---

## 🔷 웹 통신과 Protocol

- 인터넷 상에서의 통신을 말합니다

- 많은 정보들이 주고 받기에 인터넷에는 엄격한 규약이 존재하는데 이것을 protocol 이라고 부릅니다.

- 예를들어 메일을 주고 받기 위한 SMTP protocol, 파일전송의 FTP protocol, 브라우저와 웹서버와 통신하기 위해서 HTTP protocol 등이 있습니다.

## 🔷 HTTP(Hyper Text Transfer Protocol)

- Hyper Text 전송하기 위한 protocol

- HTTP 는 요청의 request 와 응답의 response 가 있습니다. Client 에서 server 로 요청하는것이 하면 서버에서 그에 맞는 응답 정보를 보내 줍니다

![image](https://user-images.githubusercontent.com/28912774/146513239-11726d27-c685-4d54-8b0c-043f95e5c33d.png)

![image](https://user-images.githubusercontent.com/28912774/146513598-6e034989-964e-4c76-a33b-24a98c42d1e3.png)

### HTTP 패킷

- HTTP 응답을 받을 때 그 정보를 패킷에 담겨서 넣는데, 패킷은 header 와 body 로 이루워져 있습니다.

- Header 에는 주로 보내는 사람, 받는 사람의 주소, 패킷의 lifecycle

- body 에는 user에서 전하는 실제 내용이 담겨 있습니다

### HTTP Method

- GET: 클라이언트가 서버에 리소스를 요청할 때 사용 (일반적으로 정보를 받아 올때 사용)

- POST: 클라이언트가 서버의 리소스를 새로 만들때 사용 (로그인, 개시글 정보 등 data 를 담아서 보내야 할때 사용)

- PUT: 클라이언트가 서버의 리소스를 전체 수정 할 때 사용 (회원정보를 전체 수정할때 주로 사용)

- PATCH: 클라이언트가 서버의 리스소를 일부 수정 할 때 사용 (회원정보를 일부 수정할때 사용)

- DELETE: 클라이언트가 서버의 리소스를 삭제 할 때 사용

- HEAD: 클라이언트가 서버의 정상 작동 여부를 확인 할 때 사용

- OPTIONS: 클라이언트가 서버에서 해당 URL 이 어떤 메소드를 지원하는지 확인 할 때 사용

- CONNECT: 클라이언트가 프록시를 통하여 서버와 SSL 통신을 하고자 할 때 사용

- TRACE: 클라이언트와 서버간 통신 관리 및 디버깅을 할 때 사용

### HTTP Status

- 100번 대 Informational: 요청 정보를 처리 중

- 200번 대 Success: 요청을 정상적으로 처리함

- 300번 대 Redirection: 요청을 완료하기 위해 추가 동작 필요

- 400번 대 Client Error: 서버가 요청을 이해하지 못함

- 500번대 Server Error: 서버가 요청 처리를 실패함

## 🔷 URLSession

- Apple 에서 HTTP / HTTPS 와 통신하게 만든 것으로 특정한 url을 이용하여 데이터를 다운로드하고 업로드 하기 위한 API 각 Session 내에서 URL 은 요청을 나타 내는 일련의 작업을 추가 합니다. URLSession 은 request 와 response 를 기본 구조를 가지고 있습니다

- request 는 server로 요청을 보낼때, 어떤 http method 를 사용할 것인지, cashing 정책을 어떻데 할것인지에 대한 설정을 할 수 있습니다.

- response 는 url 의 요청에 응답을 나타내는 객체 입니다.

### URLSessionConfiguration, URLSessionTask

- URLSessionConfiguration 을 통해서 URLSession 을 생성 할 수 있으며, 생성된 URLSession 은 한개 이상의 URLSessionTask 을 생성할 수 있습니다

- URLSession 에 담겨있는 URLSessionTask 을 통해서 실제 서버와 통신 할 수 있습니다.

- URLSession API 는 여러가지 유형의 session 을 제공하는데, URLSessionConfiguration 의 객체에 의해서 session property 를 구성 할 수 있습니다.

### URLSession 의 종류

#### Shared Session (URLSession.shared()) - 공유 세션

- singleton 으로 사용할 수 있으며, 기본요청을 하기 위한 session 입니다. custom 설정은 할 수 없지만, 쉽게 만들어 사용할 수 있습니다

#### Default Session (URLSession(configuration: .default)) - 기본 세션

- shared session 과 유사하게 작동 하지만, 직접 원하는 설정을 할 수 있으며, cash, 쿠키 등을 직접 disk 에 저장 할 수 있습니다.

- 순차적으로 data 를 처리하기 위해 delegate 를 지정할 수 있습니다

#### Ephemeral Session (URLSession(configuration: .ephemeral)) - 임시 세션

- shared session 과 비슷 하지만, cash, 쿠키, 사용자 정보등을 disk 에 저장하지 않습니다. 메모리에 올려서 session 을 연결하고, session 만료시 data 가 사라 집니다

#### Background Session (URLSession(configuration: .background)) - 백그라운드 세션

- 앱이 실행되지 않는 동안 background 에서 컨텐츠 업로드 및 다운로드를 수행 할 수 있는 session 입니다

### URLSessionTask 의 종류

#### URLSessionDataTask

- data 객체를 사용하여, 데이터를 요청하고 응답 받습니다. 주로 짧고 빈번하게 요청하는 경우에 주로 사용 됩니다

#### URLSessionUploadTask

- data 객체, 파일 형태의 data 를 업로드 하는 작업을 수행 합니다. App 이 실행되지 않았을 때, background upload 를 지원 합니다.

#### URLSessionDownloadTask

- data를 받아서 파일 형태로 저장하는 작업을 말합니다. App 이 실행되지 않았을 때, background upload 를 지원 합니다.

#### URLSessionStreamTask

- TCP/IP 을 연결 할 때 생성해서 사용하는 task

#### URLSessionWebSocketTask

- WebSocket 표준을 통해 통신하는 task

### URLSession Life Cycle

1. Session Configuration 을 결정하고, Session 을 생성

2. 통신할 URL 과 Request 객체를 설정

3. 사용할 Task 를 결정하고 그에 맞는 Completion Handler 나 Delegate 메소들을 작성

4. 해당 Task 를 실행

5. Task 완료 후 Completion Handler 클로저 호출됨

### 예제 코드

```swift
// URLSession 을 이용해서 currentWeather API를 호출하기
func getCurrentWeather(cityName: String) {
	guard let url = URL(string: "https://api.openweathermap.org/data/2.5/weather?q=\(cityName)&units=metric&lang=kr&appid=0fb8463dce1de96897cba0b1eff08e18") else { return }
	// session 을 default session 으로 설정
	let session = URLSession(configuration: .default)
	// compression handler 로써 closure 매개 변수에 data(서버에서 응답 받은 data), response(HTTP header 나 상태 코드의 metaData), error(error 코드 반환)
	session.dataTask(with: url) { [weak self] data, response, error in
		// 응답받은 response (json data)를 weatherInfo struct 에 decoding 되게 하는 logic
		let successRange = (200..<300)
		guard let data = data, error == nil else { return }
		let decorder = JSONDecoder()
		// 응답받은 data 의 statusCode 가 200번대 (200 ~ 299) 일때
		if let response = response as? HTTPURLResponse, successRange.contains(response.statusCode) {
			guard let weatherInfo =  try? decorder.decode(WeatherInfo.self, from: data) else { return }
			// debugPrint(weatherInfo)
			// 받아온 데이터를 UI 에 표시하기 위해서는 main thread 에서 작업을 진행 햐여 됩
			DispatchQueue.main.async {
				self?.weatherStackView.isHidden = false
				self?.configureView(weatherInfo: weatherInfo)
				}
			} else { // status code 가 200 번대가 아니면 error 상태 이니까 error message 생성 logic
				guard let errorMessage = try? decorder.decode(ErrorMessage.self, from: data) else { return }
				// debugPrint(errorMessage)
				// main thread 에서 alert 이 표시되게 해야됨
				DispatchQueue.main.async {
					self?.showAlert(message: errorMessage.message)
				}
		}
	}.resume() // app 이 실행되게 함
	}
```

---

🔶 🔷 📌 🔑 👉

## 🗃 Reference

weatherApp-iOS-practice code - [https://github.com/jacobkosmart/weatherApp-iOS-practice.git](https://github.com/jacobkosmart/weatherApp-iOS-practice.git)

아직은 어렵지 - [https://greatpapa.tistory.com/66](https://greatpapa.tistory.com/66)

fastcampus - [https://fastcampus.co.kr/dev_online_iosappfinal](https://fastcampus.co.kr/dev_online_iosappfinal)
