---
title: "Swift 문법 정리"
excerpt: "swift"

categories:
  - ios

toc: true
toc_sticky: true
---

# 1.상수와 변수

- 상수는 변하지 않는 일정한 값

- 변수는 변할 수 있는 값을 갖는것

```swift
import Foundation

// 상수
// let 상수명: 데이터 타입 = 값

let a: Int = 100


// 변수
// var 변수명: 데이터 타입 = 값
var b: Int = 200
b = 400

```

# 2.Swift 기본 데이터 타입

- Int: 64bit 정수가

- UInt: 부호가 없는 64bit 정수형

- Float: 32bit 부동 소수점

- Double: 64bit 부동 소수점

- Bool: true, false 값

- Character: 문자

- String: 문자열

- Any: 모든 타입을 지정하는 키워드

```swift
import Foundation

// Int
var someInt: Int = -100
someInt = 100

// UInt
var someUInt: UInt = 200

// Float
var someFloat: Float = 1.1
someFloat = 1
print(someFloat)

// Double
var someDouble: Double = 1.1
someDouble = 1

// Bool
var someBool: Bool = true
someBool = false

// Character
var someCharacter: Character = "가"
someCharacter = "A"
someCharacter = "😄"

// String
var someString: String = "안녕하세요 👉"

// 타입추론
var number = 1
```

# 3.컬렉션 타입

- Array : 데이터 타입의 값들을 순서대로 지정하는 리스트

- Dictionary : 순서 없이 key 와 value 의 한 쌍으로 데이터를 저장하는 컬렉션 타입

- Set : 같은 데이터 타입의 값을 순서 없이 저장하는 리스트

## Array 예제

```swift
import UIKit

// 빈 Array 만들기
var numbers: Array<Int> = Array<Int>()
// 1을 Array 에 추가하기
numbers.append(1)
numbers.append(2)
numbers.append(3)

// Array 요소에 Index 값으로 접근하기
numbers[0]
numbers[1]


// Array 안에 중간에 insert 하기 = 숫자 4를 index 2 번 자리에 넣기
numbers.insert(4, at: 2)
numbers

// Array 안에 값 index 0 번 자리에서 지우기
numbers.remove(at: 0)
numbers

// 출력된 문법으로 Array 를 생성하기
var names:[String] = []

```

## Dictionary 예제

```swift
// Dictionary 만들기
var dic: Dictionary<String, Int> = Dictionary<String, Int>()
// 축약된 형태로 Dictionary 만들기 = 초기값을 선언해서 만들수 있음
var dic2: [String: Int] = ["Jacob": 1]

// Dictionary 에 값 추가 하기
dic2["Emma"] = 3
dic2["John"] = 5
dic2

// Dictionary 에 값 변경하기
dic2["Jacob"] = 6
dic2

// Dictionary 값 제거하기
dic2.removeValue(forKey: "Jacob")
dic2
```

## Set 예제

```swift
// 순서와 상관없이 data 의 중복을 허용하지 않는 Set 만들기 = Set 는 축약형 으로 사용하는 방법은 없기 때문에 아래와 같이만 사용해야 함
var set: Set = Set<Int>()

// Set 에 값을 넣기
set.insert(10)
set.insert(20)
set.insert(30)
set.insert(30) // inserted false 됨 중복되기 때문에
set

// Set 안에 값 지우기
set.remove(20)
set

```

# 4.함수

함수는 작업의 가장 작은 단위이자 코드의 집합입니다 : 반복적인 프로그래밍을 피하기 위해서 사용합니다

- 함수의 기본적인 형태

```swift
func 함수명(파라미터 이름: 데이터 타입) -> 반환 타입 {
  return 반환 값
}
```

```swift
import UIKit

// func 함수명(파라미터 이름: 데이터 타입) -> 반환 타입 {
//   return 반환 값
// }

// 함수 생성
func sum(a: Int, b:Int) -> Int {
	return a + b
}
// 함수 호출
sum(a: 5, b: 3)

// 문자열 출력
func hello() -> String {
	return "hello"
}
hello()

// 반환값이 없는 함수작성
func printName() {

}

// me 값으로 Jacob 이라는 기본값을 사용할 수 있음
func greeting(friend: String, me: String = "Jacob") {
	print("Hello, \(friend)! I'm \(me)")
}

greeting(friend: "Emma")



// 전달인자 label 을 사용해서 함수 만들기

/*
 func 함수 이름(전달인자 레이블: 매개변수 이름: 매개변수 타입, 전달인자 레이블: 매개변수 이름: 매개변수 타입...) -> 반환 타입 {
		retrun 반환 값
 }

 */

func sendMessage(from myName: String, to name: String) -> String {
  return "Hello \(name)! I'm \(myName)"
}

sendMessage(from: "Jacob", to: "Emma")

// 전달 인자 label 을 사용하지 않을경우 wildcard 식별자를 사용함 : _ 를 앞에다 붙여 줌
func sendMessage2(_ name: String) -> String {
	return "Hello \(name)!"
}
sendMessage2("Jacob")


// 몇개의 값이 변수로 들어올지 모를때 가변 매개변수를 사용하는 함수 : 배열처럼 사용이 가능, 함수마다 가변 매개변수는 한가지만 가질 수 있음
func sendMessage3(me: String, friends: String...) -> String {
	return "Hello \(friends)! I'm \(me)"
}
// 여러개의 문자열을 넘기는데 array 안에 3명이 들어감
sendMessage3(me: "Jacob", friends: "Emma", "Json", "John")

```

# 5.조건문

주어진 조건에 따라서 어플리케이션을 다르게 동작하도록 하는것

## if

```swift
/*
 if 조건식 {
	실행할 구문
 }
 */

let age = 20
if age < 19 {
	print("미성년자 입니다")
}

/*
 if 조건식 {
	 조건식이 만족하면 해당 구문 실행
 } else {
	 만족하지 않으면 해당 구문 실행
 }
 */

if age < 19 {
	print("미성년자")
} else {
	print("성년자")
}


/*
 if 조건식1 {
	조건식1 을 만족할 때 실행할 구문
 } else if 조건식2 {
	조건식2를 만족 할때 실행할 구문
 } else {
  아무 조건식도 만족하지 않을 때 실행할 구문
 }
 */

let animal = "강아지"

if animal == "dog" {
	print("강아지 사료주기")
} else if animal == "cat" {
	print("고양이 사료주기")
} else {
	print("해당하는 동물 사료가 없음")
}
```

## switch

```swift
/*
 switch 비교대상 {
 case 패턴 1:
		// 패턴 1 일치할때 실행되는 구문
 case 패턴 2, 패턴 3:
		// 패턴 2,3 이 일치할때 실행되는 구문
 default:
		// 어느 비교 패턴과도 일치하지 않을 때 실행되는 구문
 }
 */

let color = "red"
switch color {
case "blue" :
	print("파란색 입니다")
case "green":
	print("초록색입니다")
case "yello":
	print("노란색 입니다")
default:
	print("찾는 색상이 없습니다")
}


// switch 문을 사용해서 숫자 범위 -20 에서 9도까지는 겨울입니다 라고 나타 내는 것
let temp = 30
switch temp {
case -20...9:
	print("겨울 입니다")
case 10...14:
	print("가을 입니다")
case 15...25:
	print("봄 입니다")
case 26...35:
	print("여름 입니다")
default:
	print("이상기온 입니다")
}

```

# 6.반복문

반복적으로 코드가 실행되게 만드는 구문

## for-in

```swift
/*
 for 루프 상수 in 순회 대상 {
	// 실행할 구문..
 }
 */

for i in 1...4 {
	print(i)
}

let arr = [1, 2, 3, 4, 5]

for i in arr {
	print(i)
}

```

## while

```swift
/*
 while 조건식 {
	// 실행할 구문
 }
 */

var num = 5

while num < 10 {
	num += 1
}

num

```

## repeat-while

```swift
/*
	repeat {
	// 실행할 구문
 } while 조건식
 */


var x = 6

repeat {
	x += 2
} while x < 5

// 조건에 맞지 않아도 한번은 실행되기 때문에 +2 가 되서 8이 출력이 됨
print(x)
```

# 7.옵셔널

값이 있을 수도 있고 없을 수도 있는 것임

nil 은 dart 언어나 다른 언어에서의 null 을 가리킴
`var name: String? = nil`

- optional `nil` 을 사용할때는 type 뒤에 ? 를 붙여 줘서 사용해야 함

```swift
var name: String?

// optional 변수에 초기값으로 값을 넣을 수 있음
var optionalName: String? = "Jacob"
print(optionalName) // 출력값으로 Optional("Jacob") 이라고 optional 값으로 출력되기때문에 재대로 실행하려면 optional binding 이 필요함
```

## Optional binding

- 명시적 해제 : 강제 해제, 비강제 해제 (옵셔널 바인딩)

  - 변수 명 뒤에 ! (느낌표) 를 붙여서 optional 을 강제로 해제 시키는데, 이방법을 사용하게 되면 강제로 프로그램 error 가 발생 할 수도 있음

  - 안전하게 해제 하기 위해서는 비강제 해제 방식 사용

- 묵시적 해제 : 컴파일러에 의한 자동 해제, 옵셔널의 묵시적 해제

```swift
var name: String?

// optional 변수에 초기값으로 값을 넣을 수 있음
var optionalName: String? = "Jacob"
print(optionalName)
// optional 강제 해제
print(optionalName!)

// optional 비강제 해제
if let result = optionalName {
	print(result)
} else {

}


// 묵시적으로 해제 optional 을 ? 대신 ! 을 사용해서 optional 을 해제시킴
let string = "12"
var stringToInt: Int! = Int(string)
print(stringToInt + 1)
```

# 8.구조체

프로퍼티와 메소드를 사용해서 구조화된 data 와 기능을 가질 수 있는 하나의 사용자 정의 데이터 타입을 만드는 것임

```swift
/*
	struct 구조체 이름 {
	프로퍼티와 메서드
 }
 */

// structure 생성
struct User {
	var nickname: String
	var age: Int

	// struct 안에 method 정의
	func information() {
		print("\(nickname) \(age)")
	}
}

// instance 생성
var user = User(nickname: "Jacob", age: 30)

// 실행
user.nickname
// user nickname 변경
user.nickname = "John"
user.nickname


// struct 의 method 실행
user.information()

```

# 9.클래스

```swift
/*
	class 클래스 이름 {
	프로퍼티와 메서드
 }
 */

// class 생성
class Dog {
	var name: String = ""
	var age: Int = 0

	// class 에서는 constructor 를 생성해줘야 함 초기화 값임
	init() {

	}

	// method 생성
	func introduce() {
		print("name \(name) age \(age)")
	}
}

// class 의 instance 생성
var dog = Dog()

dog.name = "coco"
dog.age = 3
dog.name
dog.age

dog.introduce()

```

# 10.초기화(initialization)

- 클래스 구조체 또는 열거형의 인스턴스를 사용하기 위한 준비 과정

```dart
import UIKit

/*
	init(매개변수: 타입, ...) {
	// 프로퍼티 초기화
	ㅁㄴㅇㄴ
 }
 */

// 클래스 선언
class User {
	var nickname: String
	var age: Int

	// 초기화 dart 나 Js 에서 this 가 self 로 쓰임
	init(nickname: String, age: Int) {
		self.nickname = nickname
		self.age = age
	}

	// 초기값에 기본값 설정
	init(age: Int) {
		self.nickname = "Emma"
		self.age = age
	}

	// deinitialize: instance 가 메모리에 해제되기 직전에 호출되고 클래스 인스턴스와 관련해서 정의 작업을 할 수 있음
	deinit {
		print("deinit user")
	}

}

// User instance 생성
var user = User(nickname: "Jacob", age: 30)

user.nickname
user.age

var user2 = User(age: 27)
user2.nickname
user2.age

// Swift 는 instance 가 더이상 필요하지 않으면 자동으로 소멸을 시켜 버림 user3 에 nil 을 대입 시키면 더이상 필요 없다고 판단함
var user3: User? = User(age: 23)
user3 = nil

```

# 11.프로퍼티

- 클래스, 구조체 또는 열거형 등에 관련된 값을 뜻합니다

  - 저장 프로퍼티: 인스턴스의 변수, 상수를 의미

  - 연산 프로퍼티: 연산의 값을 저장하는 것이 아니라 특정 연산값을 실행하는 것을 의미함

  - 타입 프로퍼티: 특정 인스턴스에서 사용되는것이 아닌

```swift
import Foundation

// 저장 프로퍼티

// 구조체
struct Dog {
	var name: String
	let gender: String
}


var dog = Dog(name: "Jacob", gender: "Male")
print(dog)

dog.name = "제이콥"

// dog2 는 let 으로 선언되었기 때문에 변경 프로퍼티 변경 안됨
let dog2 = Dog(name: "Emma", gender: "female")

// 구조체는 value type 이기 때문에 상수로 선언하게 되면 변수로 선언된 property 라고 해도 값이 변경이 안됨
// 단 클래스의 reference type 이여서 구조체와 다르게 클래스 instance 는 상수로 선언을해도 변수로 선언된 property 의 값을 바꿀 수 있음


// 클래스
class Cat {
	var name: String
	let gender: String

	// intialization 생성
	init(name: String, gender: String) {
		self.name = name
		self.gender = gender
	}
}

// 상수로써 instance 선언
let cat = Cat(name: "json", gender: "male")
cat.name = "Jacob"
print(cat.name)


// 연산 프로퍼티 : 저장 프로퍼티는 구조체와 클래스에서만 사용되지만, 연산 프로퍼티는 구조체, 클래서, 열거형에서도 사용이 가능함
// 연산 프로퍼티는 값을 직접적으로 저장하지는 않지만, getter, setter 를 사용해서 다른 property 와의 값들을 직접적으로 접근할 수 있게 됨

struct Stock {
	var averagePrice: Int
	var quantity: Int
	var purchasePrice: Int {
		get {
			return averagePrice * quantity
		}
		// set 에 property 값을 입력하지 않으면 newVal 의 값이 기본값으로 설정이 됨
		set(newPrice) {
			averagePrice = newPrice / quantity
		}
	}
}

var stock = Stock(averagePrice: 2300, quantity: 3)
print(stock)

// 연산형 프로퍼티 접근
stock.purchasePrice // 평균값 6900
stock.purchasePrice = 3000 // purchasePrice 에서 3000 으로 바꾸미
stock.averagePrice // averageProce : 1000


// 프로퍼티 옵져버: 프로퍼티의 값의 변화를 관찰하고 반영함 새로운 값이 같다고 하더라도, 프로퍼티가 set 될때마다 호출 된다고 보면 됨
// 프로퍼티 옵져버는 3가지 경우에만 사용이 가능: 저장 프로퍼티, overriding 이 된 계산 프로퍼티에서만 사용이 가능함

class Account {
	var credit: Int = 0 {
		// 프로퍼티 옵저버에는 값이 저정되기 직전에 호출되는 willSet 옵져버 : 새로 저장될 property 의 값을 상수 매개변수로 전달을 함 만약 지정하지 않으면 newValue 의 값이 매개변수의 값이 됨
		willSet {
			print("잔액이 \(credit)원에서 \(newValue) 원으로 변경될 예정입니다")
		}
		// 값이 저장된 직후에 호출되는 didSet 옵져버: property 의 기존값이 상수 매개변수로 전달되어짐 이 매개변수의 이름은 didSet 구문안에 사용될 수 있도록 지정할 수 있음. 만약 지정하지 않으면 기본값인 oldValue 가 매개 값이 됨
		didSet {
			print("잔액이 \(oldValue) 원에서 \(credit) 원으로 변경되었습니다")
		}
	}
}

// account instance
var account = Account()

account.credit = 1000 // 잔액이 0원에서 1000 원으로 변경될 예정입니다
// 잔액이 0 원에서 1000 원으로 변경되었습니다


// Type Property : instance 생성없이 객체 내에 property 에 접근이 가능하게 하는것인데, 프로퍼티 타입 자체와 연결하는 것을 말함 static 키워드를 사용해서 정의함

struct SomeStructure {
	static var stroedTypeProperty = "Some value." // 스토어
	static var computedTypeProperty: Int {
		return 1
	}
}

// instance 를 생성안해도 type property 는 타입 이름과 프로퍼티 이름을 연결해서 바로 사용 가능
SomeStructure.stroedTypeProperty
SomeStructure.computedTypeProperty

```

---

🔶 🔷 📌 🔑

## Reference

inswave - [http://tech.inswave.com/2018/04/02/Swift/](http://tech.inswave.com/2018/04/02/Swift/)

[Swift 문법] Swift 공식 문서 정리 - [https://icksw.tistory.com/2](https://icksw.tistory.com/2)
