---
title: "수치와 데이터를 다루는 방법"
excerpt: "cs"

categories:
  - cs

toc: true
toc_sticky: true
---

## 🔷 변수, 상수

- 변수를 사용하면 일시적으로 값이 기록해 둘 수 있고 그 값을 수정할 수 있다

- 상수를 사용하면 한번 지정한 값을 수정할 수 없으므로, 변수처럼 사용해도 실수로 값을 바꿔 쓰는 것을 막을 수 있다

### 🔶 데이터를 보관해 두는 장소로서의 변수

프로그램에서 값을 저장할 장소를 지정하는 방법에는 `변수`와 `상수` 가 있습니다

변수 : 그 값이 바뀌는 것을 의미 하는데, 실행 중 값이 바뀌는 여러가지 데이터를 메모리상에 보관 합니다

복잡한 계산을 여러 번 할 경우, 공통되는 계산을 미리 하고 그 계산 결과를 보관해 두면, 결과를 재이용할 수 있어서 효율적입니다.

그래서 중간 데이터를 고관할 장소를 확보라고, 그 장소에 이름을 붙입니다.

### 🔶 한 번 넣은 데이터를 수정할 수 없는 상수

변수에 들어 있는 데이터는 고쳐 쓸 수 있습니다. 몇 번이라도 값이 바뀔 수 있어서 다른 처리에서 수정될 가능성이 있습니다. 이런 상황은 프로그램 내용에 따라서는 오류가 발생 할 위험이 높아지는 것을 의미합니다.

한번 데이터를 넣으면 더는 수정할 수 없는 값을 `상수` 라고 합니다. 상수는 변수와 마찬가지로 같은 값을 여러 곳에서 사용하더라도 그 값을 다시 쓸 필요가 없습니다

## 🔷 예약어, 리터럴, 매직넘버

- 변수명에는 알파벳이나 숫자, 언더스코어 등을 사용하지만, 예약어로 지정된 키워드는 사용할 수 없다

- 소스 코드 속에 갑자기 숫자가 등장하면 겉보기엔 의미를 알 수 없기에, 적절한 이름을 붙인 상수 등에 저장한 후 사용하는 것이 바람직하다

### 🔶 변수명 등에 쓸 수 없는 예약어

변수 이름(변수명)으로 쓸 수 있는 단어에는 프로그래밍 언어에 따라 제한이 있습니다.

변수명으로 사용할 수 없는 단어가 프로그래밍 언어마다 정해져 있습니다. 병수명 등에 사용하지 않도록 미리 정해 놓은 키워드를 `예약어` 라고 합니다.

### 🔶 소스 코드 속에 등장하는 리터럴과 매직넘버

소스 코드에 등장하느 ㄴ문자나 숫자 등을 `리터럴` 이라고 합니다. 그냔 값을 쓰기만 해선, 소스코드를 작성한 본인 이외에는 의미를 알 수 없습니다. 이러한 값을 `매직넘버` 합니다.

## 🔷 배열, 정적 배열, 동적 배열, 다차원 배열

- 배열을 사용하면 여러 개의 값을 한꺼번에 정의할 수 있으며, 선두에서부터 번호를 지정하여 각 요소에 직접 엑세스 할 수 있다

- 배열 주간에 요소를 추가하거나 중간 요소를 삭제할 경우에는 나머지 요소의 이동이 필요하기 때문에 요소 수가 많으면 처리에 시간이 걸린다

### 🔶 사전에 영역을 확보하는가? 실행 시에 영역을 확보하는가?

같은 형의 데이터를 연속으로 나열한 것을 `배열` 이라고 하고, 배열 내 각각의 데이터를 요소라고 합니다. 배열을 사용함으로써 복수의 데이터를 모아서 정의 할 수 있을 뿐만 아니라, 각 요소에는 선두로부터 일련번호가 붙어 있어, 그 번호의 첨자(index) 를 지정해서 요소에 엑세스 할 수 있습니다. index 는 0 부터 시작 됩니다.

사전에 상자의 수 (배열의 크기) 를 정해 확보하는 배열을 `정적 배열` 이라고 합니다.

주어지는 데이터으 ㅣ양ㅇ을 모르는 등 배열 요소수로 필요한 사이즈가 프로그램 실행 전에 불분명한 경우에는 실행 시에 영역을 증감하는 방법이 사용됩니다. 이것은 `동적배열` 이라고 불리며 필요에 따라 요소 수를 변경할 수 있습니다.

### 🔶 배열 안에 배열을 넣다

배열에 저장할 수 있는 요소는 정수형뿐만 아니라 소수점수나 문자 등도 가능합니다. 또한 요소로서 배열을 저장할 수 있어, 이를 다차원 배열이라고 합니다.

## 🔷 구조체 열거형

- 구조체를 사용하면 다른 형의 데이터를 한꺼번에 다룰 수 있다

- 열거형을 사용하면 저장할 수 있는 값을 제한할 수 있어, 구현 시의 실수를 줄이고 읽기 쉬운 소스 코드를 작성 할 수 있다

### 🔶 형이 다른 데이터를 한꺼번에 다룬다

배열에서는 같은 형의 데이터만 다룰 수 있지만, 관련된 여러 항목의 형이 달라도 한꺼번에 방법을 구조체 (struct) 가 있습니다. 구조체를 사용하기 위해서는 먼저 구조체에 들어가는 형을 정의하고, 그 정의한 형을 이용할 변수를 선언할 필요가 있습니다

### 🔶 가질 수 있는 값을 모두 열거한다

특정한 값을 저장할 수 있는 `열거형` 이 있습니다. 대입되는 값을 보면 내용을 알 수 있듯이, 구현 시 실수를 줄일 수 잇을 뿐만 아니라, 다른 사람이 소스 코드를 읽을 때도 원활하게 이해할 수 있습니다.

## 🔷 연상 배열, 해시 함수

- 연상 배열을 사용하면 배열의 인덱스로 이름을 지정하여 엑세스 할 수 있으므로, 소스 코드를 알기 쉬어 진다

- 해시에 사용되는 해시 함수에는 같은 입력에서는 같은 출력을 얻을 수 있지만, 다른 입력에서는 같은 출력을 얻기 어려운 함수가 사용된다

### 🔶 이름으로 액세스 하는 배열

배열에 접근할 때느 ㄴ목표 요소의 번호로서 첨자에 수치를 저정합니다. 수치 이외의 방법으로 접근할 수 있는 데이터 구조도 있는데 이를 `연상 배열` 이라고 합니다. 연상 배열은 배열은 프로그래밍 언어에따라 연상 리스트, 딕셔너리, 해시, 맥 이라고 부릅니다

![image](https://user-images.githubusercontent.com/28912774/152716606-fac2953c-4845-4d31-a280-4cf10ca1cd51.png)

### 🔶 보안 등에서도 사용되는 해시

연상 배열을 해시라고 부르는 이유는 해시 함수의 존재가 있습니다. 해시 함수는 요약 함수라고도 불리며, 주어진 값에 어떤 변환 처리를 하여 출력을 얻는 함수로 입력과 같으면 같은 출력을 얻을 수 있다는 특징이 있습니다.
연상 배열에 사용되는 것은 해시 테이블이라 불리며, 복수의 입력에서 같은 출력이 나오는 경우가 적다라는 특징을 갖는 것이 중요합니다. 해시 함수에서 같은 결과가 출력이 되는 것을 충돌이라고 하며, 충돌이 발생하면 대처가 필요하므로 처리 효율이 떨어 집니다.

보안이나 함호에 관한 상황에서는 `단방향 해시함수` 라 불리는 함수가 이용됩니다.

- 입력이 조금 바뀌면, 출력은 크게 바뀐다.

- 출력에서 입력을 역산하기는 어렵다

## 🔷 메모리 구조를 이해하고 데이터 다루기 (Address, Pointer)

- 메모리 위치를 나타내는 Address 에는 물리 어드레스와 논리 어드레스가 있다

- 프로그램에서 어드레스를 다루려면 포인터를 사용하고, 포인터에 저장된 어드레스에 접근하여 변수나 배열을 조작한다

### 🔶 메모리 위치를 나타내는 Address

프로그램에서 사용하는 변수나 배욜은 실행 시 컴퓨터의 메모리상에 배치 됩니다. 이때 메모리에는 장소를 나타내는 `어드레스` 라고 하는 일련 번호가 붙어 있습니다.

선언한 변수나 배열이 메모리의 어디에 배치되어 있는지 어드레스를 프로그램에서 참조할 수 있습니다.

![image](https://user-images.githubusercontent.com/28912774/152717480-25db203d-4492-4099-9f8f-3f94b0ca3a26.png)

### 🔶 Address 로 메모리를 조작하는 Pointer

프로그램에서 어드레스를 조작하기 위해서 제공되는 기능으로 `포인터` 가 있습니다. 포인터는 포인터형 변수를 준비해서 변수나 배열의 주소를 보관하는 깃으로 사용합니다

포인터는 메모리상의 잘못된 위치의 데이터에도 접근할 수 있어, 보안상 문제가 발생하거나 프로그램이 이상 종료 될수 있습니다.

![image](https://user-images.githubusercontent.com/28912774/152717803-257998d4-4e40-4ba1-aeca-36f0fd05336e.png)

## 🔷 데이터를 순서대로 탐색하는 자료 구조 (연결 리스트, 양방향 리스트, 환상 리스트)

- 다음 요소의 어드레스를 유지해서, 선두 부터 순서대로 탐색할 수 있는 데이터 구조를 연결 리스트라고 한다

- 연결 리스트에서는 삽입이나 삭제를 배열보다 더 빠르게 할 수 있지만, 특정 위치의 요소를 참조하는 것은 배열보다 시간이 걸린다.

### 🔶 처음부터 순서대로 액세스하는 선형 리스트

배열에서는 각 요소의 위치를 지정하여 임의의 요소에 접근할 수 있지만, 중간에 데이터를 삽일할 때는 기존 데이터를 뒤로 밀어주는 처리, 중간 데이터를 삭제할 때는 기존 데이터를 앞으로 당겨 채우는 처리가 필요합니다.

데이터양이 많아지면 이 처리에 시간 걸리기 때문에 고안한 자료 구조가 `연결리스트`(단방향 리스트)입니다. 연결 리스트느 ㄴ데이터의 내용과 함께 다음 데이터의 어드레스를 나타내는 값을 보관하여, 데이터를 차례로 연결하는 구조로 되어 있습니다.

![image](https://user-images.githubusercontent.com/28912774/152718471-4cd7cb79-e70a-462c-a892-3f7f73fea920.png)

![image](https://user-images.githubusercontent.com/28912774/152718864-70c9c6af-dcf8-441b-b759-1bbbcdd10882.png)

### 🔶 앞뒤로 리스트를 탐색하는 양방향 리스트와 환상 리스트

단방향 연결 리스트는 다음 데이터의 어드레스를 가지고 있을 뿐이라서, 역방향으로 액세스할 수는 없습니다. 하지만, 직전 데이터의 어드레스도 가지는 데이터 구조로 `양방향 리스트` 가 있습니다.

연결 리스트의 끝 데이터에 선두 데이터의 어드레스를 저장함으로써, 끝까지 탐색한 다음에 다시 처음부터 탐색 할 수 있도록 한 데이터 구조를 `환상 리스트`라고 합니다

![image](https://user-images.githubusercontent.com/28912774/152719562-6a7b3854-49fc-4257-bc5e-92f9e6ec1733.png)

## 🔷 Stack(Last in First out), Queue(First in First out)

- 마지막으로 저장한 데이터부터 꺼내는 데이터 구조를 스택이라 하며, 깊이 우선 탐색 등에 자주 사용된다

- 처음 저장한 데이터부터 꺼내느 데이터 구조를 큐라고 하며, 너비 우선 탐색 등에 자주 사용된다

### 🔶 쌓아 올린 데이터를 순서대로 처리한다

배열에 데이터를 저장하거나 꺼내는 장면을 생각하면, 가능하는 요소를 이동하지 않고 처리하는 방법이 필요합니다. 선두나 말미 중 한방향으로만 데이터를 넣고 빼는 방법이 많이 사용됩니다.

마지막에 저장한 데이터부터 꺼내는 구조를 `Stack` 이라고 하고 마지막에 저장한 데이터를 첫번째로 꺼내기에 LIFO(Last In First Out) - 깊이 우선 탐색에 자주 사용되는 데이터 구조입니다

배열을 사용하여 스택을 표현할 경우, 배열의 마지막 요소가 잇는 위치를 기억해 두고, 추가할 데이터를 넣을 위치나 삭제할 데이터의 위치를 알 수 있기 때문에 데이터 추가 및 삭제를 빠르게 처리 할 수 있습니다

![image](https://user-images.githubusercontent.com/28912774/152724157-4a840bb1-9994-405a-87e9-d1abcd7169a9.png)

### 🔶 도착한 데이터를 순서대로 처리하다

저장한 순서대로 데이터를 꺼내는 구조를 `Queue` 라고 합니다. 가장 먼저 넣은 데이터를 꺼내기 때문에 FIFO(First In First Out) 이라고 부르기도 합니다. 너비 우선 탐색에서 자주 사용됩니다.

큐의 경우는 배열의 첫 번째 요소가 있는 위치와 마지막 요소가 있는 위치를 기억해 둡니다. 데이터를 추가할 경우 마지막 위치에 연달아 등록하고, 삭제할 경우 선두의 요소가 있는 위치에서 꺼냅니다. 저장하는것은 인큐, 꺼내는 것을 디큐라고 합니다.

![image](https://user-images.githubusercontent.com/28912774/152724191-3685c516-d4e1-4c43-8661-125fdd860129.png)

## 🔷 트리 구조, 이진 트리, 완전이진 트리, 밸런스 트리

- 트리구조를 사용하면, 계층적인 데이터를 표현할 수 있다

- 이진 트리가 자주 사용되며, 완전 이진 트리는 배열로 표현할 수도 있다

### 🔶 계층 구조를 표현할 수 있는 트리 구조

폴더 구성 처럼 나무가 하늘 과 땅을 거꾸로 한 형태로 연결되어 있는 구조를 `트리 구조` 라고 합니다.

트리구조는 각 `노드` 부분에서 그 노드를 연결하는 선 `링크`, 노드의 시작지점을 `루트`, 맨 아래 노드를 `리프` 라고 합니다

위에 있는 노드를 부모노드, 밑에는 자식 노드 라고 합니다

![image](https://user-images.githubusercontent.com/28912774/152726254-0cc63421-f938-4d20-980a-0eb8ef373a8c.png)

### 🔶 프로그램에서 다루기 쉬운 이진 트리와 완전 이진 트리

트리 구조에서 가장 많이 쓰이는 것으로 `이진 트리` 가 있습니다. 노드에서 나온 링크가 최대 2줄 밖에 없는 트리 구조 입니다.

이진 트리 중에서도, 모든 리프가 같은 계층에 있으면서 리프이외의 모든 노드가 2개의 자식 노드를 가진것을 `완전 이진 트리` 라고 합니다.

완전 이진 트리는 배열로 표현 할 수 있습니다.

완전 이진 트리 처럼 리프의 깊이가 거의 같도록 균등하게 요소를 배치한 트리를 밸런스 트리 (균형 이진 트리) 라고 합니다

![image](https://user-images.githubusercontent.com/28912774/152726280-eedfbbf0-71b5-48df-94b9-6cf85f56f7d1.png)

---

<!-- 🔶 🔷 📌 🔑 👉 -->

## Reference

그림으로 배우는 프로그래밍 구조 - [https://book.jacobko.info/#/book/8931465599](https://book.jacobko.info/#/book/8931465599)
