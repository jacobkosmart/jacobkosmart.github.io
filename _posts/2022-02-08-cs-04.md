---
title: "흐름도와 알고리즘"
excerpt: "cs"

categories:
  - cs

toc: true
toc_sticky: true
---

## 🔷 흐름도, 프로그램 처리의 기본

- 처리 흐름을 설명하기 위해 사용되는 그림으로 흐름도가 있다

- 프로그램은 순차처리, 조건분기, 반복을 조합해서 많은 것을 표현할 수 있다

- 흐름도를 그리고 나서 프로그램을 작선하는 일은 거의 없지만, 다른 사람에게 설명할 때는 아직 유효하다

### 🔶 흐름도가 필요한 이유

### 🔶 흐름도를 그리는 상황

## 🔷 조건분기, if, 삼향연산자

- 조건에 따라 처리를 바꾸려면 if 와 else 에 의한 조건분기를 사용한다

- 조건분기를 한 줄로 표현하는 삼향 연산자가 사용되는 경우도 있다

### 🔶 if에 의한 조건 분기

### 🔶 두가지 조건을 한꺼번에 기술 할 수 있는 삼향 연산자

## 🔷 Loop

- 횟수를 지정하여 반복한다. 리스트를 순서대로 처리하는 경우는 for 를 사용한다

- 조건을 만족하는 경우에만 반복할 경우는 while 을 사용한다

### 🔶 지정한 횟수 만큼 실행한다

### 🔶 조건을 만족하는 동안만 실행한다

## 🔷 함수, 프로시저, 인수, 반환값

- 함수나 프로시저를 정의해 호출함으로써 인수를 변경하면서 같은 작업을 몇 번이든 실행할 수 있다

- 함수나 프로시저에 넘겨주는 파라미터를 인수라고 하고, 반대로 함수에서 호출한쪽에 돌려주는 값을 반환 값이라고 한다

### 🔶 함수와 프로시저

### 🔶 인수와 반환값

## 🔷 값 전달, 참조 전달, immutable, mutable

- 값 전달에서는 함수 내에서 가인수 값을 변경해도 실인수 값이 변경되지 않지만, 참조 전달에서는 가인수 값을 변경하면 실인수 값도 변경된다

### 🔶 호출한 쪽에 영향을 주지 않는 값 반환

### 🔶 호출한 쪽 값도 변경하는 참조 전달

### 🔶 값 전달 방법

## 🔷 Scope, Global , Local Variable

- 변수의 스코프로서 글로벌 변수와 로컬 변수가 많은 언어에 존재한다

- 글로벌 변수를 사용하면 다른 변수의 내용을 바꿔버릴 위험이 있으므로, 가능한 로컬 변수로만 처리하는 것이 바람직하다

### 🔶 변수를 덮어쓰기를 방지하는 Scope

### 🔶 어디에서든 접근할 수 있는 글로벌 변수

### 🔶 일부에서만 접근할 수 있는 로컬 변수

## 🔷 재귀함수

- 함수 안에서 자신의 함수를 호출하는 것을 재귀하고 한다. 소스 코드를 단순하게 할 수 있으나, Stack overflow 에 주의가 필요하다

- 재귀를 루프로 변환하여, 계층이 깊어지는 것을 막을 수 있는 경우도 있다

### 🔶 함수 안에서 함수를 호춯하는 재귀

### 🔶 루프로 재귀와 같은 결과를 얻는다

## 🔷 예외, 예외 처리

- 예상 빡의 입력 등이 주어졌을 때 발생하는 문제를 예외라고 한다

- 예외 발생 시 프로그램이 비정상적으로 종료되지 않도록 예외처리를 구현해 둘 필요가 있다

### 🔶 예상 밖의 문제를 방지하는 예외처리

### 🔶 초보자가 간과하기 쉬운 제로 나눗셈

## 🔷 Iterator

- 이터레이터를 사용하면 리스트의 선두부터 순서대로 접근하는 처리를 데이터 구조에 관계없이 동일하게 구현할 수 있다

### 🔶 배열 등의 반복

### 🔶 집합을 다루는 함수에서 사용한다

## 🔷 메모리 누수, 가비지 컬렉션

- 함수 시작 부분 등에서 정적으로 확보한 메모리 영역은 해당 함수가 종료되면 자동으로 해제된다

- 동적으로 확보한 메모리 영역은 자동으로 해제되지 않으므로 수동으로 해제해야 하지만, 최근 프로그래밍 언어에서는 가비지 컬렉션에 의해 자동으로 해제되는 경우도 있다

### 🔶 정적으로 확보한 메모리의 경우

### 🔶 동적으로 확보한 메모리를 해제한다

## 🔷 정렬, 선택정렬, 삽입정렬

- 데이터를 정렬하는 것을 sort 라하며, 구현이 용이한 방법으로 선택 정렬이나, 삽입 정렬이 있다

- 삽입 정렬은 이미 정렬된 배열에 대해서는 고속으로 동작한다

### 🔶 데이터를 정렬한다

### 🔶 최솟갑을 찾아 선두로 이동하는 선택 정렬

### 🔶 정렬 완료 부분을 늘려가는 삽입 정렬

## 🔷 버블 정렬, 칵테일 셰이커 정렬

- 이웃한 데이터 교환을 반복하여 정렬하는 방법을 버블 정렬이라고 한다. 처리는 느리지만 구현이 용이하여 자주 소개된다

- 버블 정렬을 개선한 칵테일 셰이커 정렬도 탐색 범위를 좁힘으로써 좀 더 빠르게 처리할 수 있는 알고리즘으로 알려져 있다

### 🔶 이웃끼리 교환을 반복하는 버블 정렬

### 🔶 양방향 버블 정렬을 구현하는 칵테일 쉐이커 정렬

## 🔷 머지정렬, 퀵정렬

- 머지 정렬이나 퀵 정렬을 이용하면 구현은 복잡하지만 빠르게 처리할 수 있다

- 퀵 정렬은 선택한 기준에 따라 성능이 크게 달라질 수 있다

### 🔶 어떤 데이터라도 고속으로 처리할 수 있는 머지 정렬

### 🔶 기준 선택이 중요한 퀵 정렬

## 🔷 선형 탐색, 이진 탐색

- 데이터가 적을 때는 선형 탐색을 사용하면 간단히 구현할 수 있다

- 데이터가 많을 때는 데이터를 정렬한 후 이진 탐색 기법으로 탐색하면 고속으로 찾을 수 있다

### 🔶 앞에서부터 순서대로 찾는 선형 탐색

### 🔶 기준 데이터의 앞뒤를 찾는 이진 탐색

## 🔷 너비 우선 탐색, 깊이 우선 탐색, 가지 치기

- 트리 구조 탐색 방법으로 너비 우선 탐색과 깊이 우선 탐색이 있으며, 각각의 특징을 이해하고 구분하여 사용할 필요가 있다

- 대전형 게임에서는 가지치기로 탐색 범위를 좁히는 겂이 중요하다

### 🔶 계층으로 데이터를 가지는 트리 구조

### 🔶 깊이 우선 탐색 및 너비 우선 탐색

## 🔷 문자열 탐색, 완전 탐색법(부루트포스), BM (Boyer-Moore)법

- 선두부터 순서대로 문자열을 탐색하는 방법으로는 완전탐색(브루트포스)법이 있다

- 문자열 탐색에서 개선된 방법으로 BM법이 있다

### 🔶 앞에서부터 탐색을 반복하는 완전 탐색법

### 🔶 일치하지 않는 만큼 점프하여 탐색하는 BM(Boyer-Moore)법

---

<!-- 🔶 🔷 📌 🔑 👉 -->

## Reference

그림으로 배우는 프로그래밍 구조 - [https://book.jacobko.info/#/book/8931465599](https://book.jacobko.info/#/book/8931465599)
