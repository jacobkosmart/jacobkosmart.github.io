---
title: "11-2.Redux-advanced"
excerpt: "react"

categories:
  - react

toc: true
toc_sticky: true
---

---

## 1.Async action with Redux

container 는 redux 의 로직만 다루고 (그래서 비동기 작업도 여기서 실행함)

이 방법은 redux 에 middleware 를 사용하지 않고 비동기 호출하는 방식임

### actions.js 에서 users types 설정함

```js
// users types

// github API 호출을 시작하는 것을 의미함
export const GET_USERS_START = "GET_USERS_START";
// github API 호출에대해서 응답이 성공적으로 돌아온 경우를 의미함
export const GET_USERS_SUCCESS = "GET_USERS_SUCCESS";
// github API 호출에대해서 응답이 실패한 경우를 의미함
export const GET_USERS_FAIL = "GET_USERS_FAIL";

export const getUsersStart = () => {
  return {
    type: GET_USERS_START,
  };
};

export const getUsersSuccess = (data) => {
  return {
    type: GET_USERS_SUCCESS,
    data,
  };
};

export const getUsersFail = (error) => {
  return {
    type: GET_USERS_FAIL,
    error,
  };
};
```

### userListContainer.js 에서 비동기 작성 실행

```js
import { useCallback } from "react";
import { useDispatch } from "react-redux";
import { useSelector } from "react-redux";
import UserList from "../components/UserList";
import { getUsersFail, getUsersStart, getUsersSuccess } from "../redux/actions";
import axios from "axios";

const UserListContainer = () => {
  // state 에서 users.data 를 불러옴
  const users = useSelector((state) => state.users.data);
  // useDispatch 사용
  const dispatch = useDispatch();

  // 비동기 함수 api 호출
  const getUsers = useCallback(async () => {
    try {
      // getUsersStart 액션 실행
      dispatch(getUsersStart());
      // API 호출
      const res = await axios.get("https://api.github.com/users");
      // 호출 성공시 response.data 가져옴
      dispatch(getUsersSuccess(res.data));
      // 에러 발생시 dispatch error 실행
    } catch (error) {
      dispatch(getUsersFail(error));
    }
    // dispatch 될때마다만 적용 dependency
  }, [dispatch]);

  // UserList 에 users, getUsers props 전송함
  return <UserList users={users} getUsers={getUsers} />;
};

export default UserListContainer;
```

```js
// in UserListContainer.jsx

import { useCallback } from "react";
import { useDispatch } from "react-redux";
import { useSelector } from "react-redux";
import UserList from "../components/UserList";
import { getUsersFail, getUsersStart, getUsersSuccess } from "../redux/actions";
import axios from "axios";

const UserListContainer = () => {
  // state 에서 users.data 를 불러옴
  const users = useSelector((state) => state.users.data);
  // useDispatch 사용
  const dispatch = useDispatch();

  // 비동기 함수 api 호출
  const getUsers = useCallback(async () => {
    try {
      // getUsersStart 액션 실행
      dispatch(getUsersStart());
      // API 호출
      const res = await axios.get("https://api.github.com/users");
      // 호출 성공시 response.data 가져옴
      dispatch(getUsersSuccess(res.data));
      // 에러 발생시 dispatch error 실행
    } catch (error) {
      dispatch(getUsersFail(error));
    }
    // dispatch 될때마다만 적용 dependency
  }, [dispatch]);

  // UserList 에 users, getUsers props 전송함
  return <UserList users={users} getUsers={getUsers} />;
};

export default UserListContainer;
```

### Present component 인 userList에 받은 props data 를 뿌려 줍니다

```js
import { useEffect } from "react";

const UserList = ({ users, getUsers }) => {
  useEffect(() => {
    getUsers();
  }, [getUsers]);

  if (users.length === 0) {
    return <p>현재 유저 정보 없음</p>;
  }
  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>{user.login}</li>
      ))}
    </ul>
  );
};

export default UserList;
```

## 2.Redux middleware

> [Redux middleware 자세히 보기](https://redux.js.org/understanding/history-and-design/middleware)

- middleware 가 **dispatch** 의 앞뒤에 코드를 추가할수 있게 해줍니다.

- middleware 가 여러개면 middleware 가 **순차적으로** 실행됩니다.

- 두가지 단계가 있는데.

  - store를 만들때, middleware를 성정하는 부분 `{createStore, applyMiddleware} from redux`

  - dispatch가 호출될때 실제로 middleware를 통과하는 부분

- dispatch 메소드를 통해 store로 가고 있는 액션을 가로채는 코드임

- middleware 는 `createStore()` 하는 부분에서 설정되어야 하기 때문에 `store.js` 파일에서 설정을 주로 해줍니다.

```js
// in store.js

import { applyMiddleware, createStore } from "redux";
import todoApp from "./reducers/reducer";

const middleware1 = (store) => {
  //next 라고 다음 middleware를 지칭하는 형태로 사용함
  console.log("middleware1", 0);
  return (next) => {
    console.log("middleware1", 1, next);
    return (action) => {
      console.log("middleware1", 2);
      const returnValue = next(action);
      console.log("middleware1", 3);
      return returnValue;
    };
  };
};

const middleware2 = (store) => {
  //next 라고 다음 middleware를 지칭하는 형태로 사용함
  console.log("middleware2", 0);
  return (next) => {
    console.log("middleware2", 1, next);
    return (action) => {
      console.log("middleware2", 2);
      const returnValue = next(action);
      console.log("middleware2", 3);
      return returnValue;
    };
  };
};

// todoApp 뒤에있는 것이 enhancer 인 applyMiddleware 함수를 사용함
const store = createStore(todoApp, applyMiddleware(middleware1, middleware2));

export default store;
```

console.log 로 보게 되면 dispatch 될때 마다 순서가 확인하는게 중요합니다.

middleware1 2 => middleware2 2 => middleware2 3 => middleware3 3

![image](https://user-images.githubusercontent.com/28912774/135610771-ca11013a-bbfd-432f-b3f8-059dfd29cfee.png)

redux middleware 는 위와 같이 구현하는 하기 위해 middleware 플러그인을 사용합니다.

## 3.redux-devtools

middleware를 설치해서 브라우저에 있는 devtools를 연결하는 작업을 하는것을 redux-devtools 입니다.

### 설치

```bash
yarn add redux-devtools-extension -D
```

`applyMiddleware` 의 실행 결과를 `composeWithDevTools`로 감싸서 실행해 줍니다. 그렇게 하면 redux-devtools-extension 으로 데이터를 보낼 준비가 된것입니다.

```js
//  in store.js

const store = createStore(todoApp, composeWithDevTools(applyMiddleware()));
```

> [Redux DevTools Extension Github](https://github.com/zalmoxisus/redux-devtools-extension)

- 주로 chrome 을 사용하는데 크롬 웹 스토어에 Redux DevTools 를 설치합니다.

![image](https://user-images.githubusercontent.com/28912774/135613055-afc4238c-29cf-4aa6-b1c0-b6b107029ff9.png)

- 주로 redux에 문제가 있을 경우에 devTools 를 사용해서 문제 해결을 하게 됩니다.

![image](https://user-images.githubusercontent.com/28912774/135614244-330aaaa9-9836-4a85-bd41-c0e18158d029.png)

## 4.redux-thunk

- redux middleware 중에서 가장많이 사용되고 있는 라이브러리 인 redux-thunk 입니다.

> [redux-thunk](https://github.com/reduxjs/redux-thunk)

- redux를 만든 사람이 만든 라이브러리

- redux에서 비동기 처리를 위한 라이브러리

- 액선 생성자를 활용하여 비동기 처리

- 액션 생성자가 액션을 리턴하지 않고, 함수를 리턴함

### 설치

```bash
yarn add redux-thunk
```

- middleware는 함수이기 때문에 라이브러리부터 함수를 import 한 다음에 함수를 applyMiddleware 안으로 넣어야 함

- thunk 는 함수 생성자가 함수를 return 할때만 반응하고, 원래대로 action 객체를 return 할때는 기존 동작 처럼 동작하기 합니다.

```js
const store = createStore(todoApp, composeWithDevTools(applyMiddleware(thunk)));
```

- action.js 에서 Thunk 함수에서 fetch API 를 사용합니다.

```js
// action.js

export const getUsersThunk = () => {
  return async (dispatch) => {
    try {
      // getUsersStart 액션 실행
      dispatch(getUsersStart());
      // API 호출
      const res = await axios.get("https://api.github.com/users");
      // 호출 성공시 response.data 가져옴
      dispatch(getUsersSuccess(res.data));
      // 에러 발생시 dispatch error 실행
    } catch (error) {
      dispatch(getUsersFail(error));
    }
  };
};
```

- 기존 fetch 한곳에서는 `getUsersThunk()` 를 호출해서 사용합니다

```js
import { getUsersThunk } from "../redux/actions";

const getUsers = useCallback(() => {
  dispatch(getUsersThunk());
}, [dispatch]);
```

- 기존에는 비동기 로직이 container 에서 이뤄졌다면 redux-thunk 를 사용하면 action 을 다루는 action 생성함수에서 처리하게 되고 container 는 그냥 action 생성자를 component 에 전달하는 역활을 합니다

- 이렇게 될경우에는 실제로 dispatch 되는 로직들은 action 에서 관리되기 때문에 관심사가 적절히 분리가 됩니다.

- 이와같이 redux-thunk 는 비동기 작업할때 보다 코드를 간결화 하면서 효율적으로 사용할 수 있는 라이브러리 입니다.

## 5.redux-promise-middleware

🔶 🔷 📌 🔑

## Reference

- React redux official site - [https://react-redux.js.org/tutorials/quick-start](https://react-redux.js.org/tutorials/quick-start){:target="\_blank"}

- Redux middleware - [https://redux.js.org/understanding/history-and-design/middleware](https://redux.js.org/understanding/history-and-design/middleware){:target="\_blank"}
