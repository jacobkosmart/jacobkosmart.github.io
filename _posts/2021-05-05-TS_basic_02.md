---
title: "02.TS ë¬¸ë²•"
excerpt: "TypeScript"

categories:
  - TypeScript

toc: true
toc_sticky: true
last_modified_at:
---

---

# TypeScript ë¬¸ë²•

> from ê³µì‹ ì‚¬ì´íŠ¸ : [(https://www.typescriptlang.org/)](https://www.typescriptlang.org/){:target="\_blank"}

## 1.TS type vs JS type

ğŸ“Œ TS type vs TS type

| Static types (TS)            | Dynamic types (JS)                               |
| ---------------------------- | ------------------------------------------------ |
| set during dev               | resolved at runtime                              |
| ê°œë°œí•˜ëŠ” ì¤‘ê°„ì— type checked | ê°œë°œí• ë•ŒëŠ” ëª¨ë¥´ê³  ì‹¤ì œ runtime ì‹œì— type checked |

```js
// JS ì—ì„œ type ì´ ì•ˆë°›ì„ë•Œ error ì¶œë ¥ ë°©ë²•
function add(n1, n2) {
  if (typeof n1 !== "number" || typeof n2 !== "number") {
    throw new Error("Incorrect input!");
  }
  return n1 + n2;
}
```

```ts
// TS ì—ì„œ type ì„¤ì •í•˜ê¸° (ìœ„ì˜ JS ì™€ ê²°ê³¼ ê°’ì€ ê°™ìŒ)

function add(n1: number, n2: number) {
  return n1 + n2;
}

const result = add(39, 28);
```

- TS ì—ì„œ type annotation í•´ì£¼ê²Œ ë˜ë©´ JS ì½”ë“œì—ì„œ runtime ë•Œ error check í•´ì¤˜ì•¼ í•˜ëŠ”ê²ƒì„ ì•ˆí•´ì¤˜ë„ ë¨

- ë¨¼ì € error ê°€ ë°œìƒ í•  ê²½ìš°, í•œ step ë¨¼ì € error ë¥¼ check í•  ìˆ˜ ìˆìŒ

> ğŸ“from TS ê³µì‹ ì‚¬ì´íŠ¸ : [(https://www.typescriptlang.org/)](https://www.typescriptlang.org/){:target="\_blank"}

- For programs to be useful, we need to be able to work with some of the simplest units of data: numbers, strings, structures, boolean values and the like

- ğŸ“¦ ì¦‰, í”„ë¡œê·¸ë¨ì´ ìœ ìš©í•˜ë ¤ë©´, ê°€ì¥ ê°„ë‹¨í•œ ë°ì´í„° ë‹¨ìœ„ë¡œ ì‘ì—… í•  ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤: numbers, strings, structures, boolean ê°’ ë“±ë“±

- In TypeScript, we support the same types as you would expect in JavaScript, with an extra enumeration type thrown in to help things along.

- TypeScriptì—ì„œ í”„ë¡œê·¸ë¨ ì‘ì„±ì„ ìœ„í•´ ê¸°ë³¸ ì œê³µí•˜ëŠ” ë°ì´í„° íƒ€ì…

- **ì‚¬ìš©ìê°€ ë§Œë“  íƒ€ì…ì€ ê²°êµ­ ì´ ê¸°ë³¸ ìë£Œí˜•ë“¤ë¡œ ë‚˜ëˆ  ì§‘ë‹ˆë‹¤**

  - **`ECMAScript` í‘œì¤€ì— ë”°ë¥¸ ê¸°ë³¸ ìë£Œí˜•ì€ 6ê°€ì§€**

    - `Boolean`

    - `Number`

    - `String`

    - `Null`

    - `Underfined`

    - `Symbol` (EC6 ì—ì„œ ì¶”ê°€ë¨)

    - `Array` : object í˜•

  - **í”„ë¡œê·¸ë˜ë°ì„ ë„ìš¸ ëª‡ê°€ì§€ íƒ€ì…ì´ ë” ì‚¬ìš©ë©ë‹ˆë‹¤.**

    - `Any`, `Void`, `Never`, `Unknown`

    - `Enum`

    - `Tuple` : object í˜•

## 2.Primitive Types

ğŸ“Œ Object, Reference í˜•íƒœê°€ ì•„ë‹Œ ì‹¤ì œ ê°’ì„ ì €ì¥í•˜ëŠ” ìë£Œí˜•ì…ë‹ˆë‹¤.

ğŸ“Œ Primitive Type í˜•ì˜ ë‚´ì¥ í•¨ìˆ˜ë¥¼ ì‚¬ìš© ê°€ëŠ¥í•œê²ƒì€ ìë°”ìŠ¤í¬ë¦½íŠ¸ ì²˜ë¦¬ ë°©ì‹ ë•ë¶„ì…ë‹ˆë‹¤.

- (ES2015 ê¸°ì¤€) 6ê°€ì§€

  - `boolean`

  - `number`

  - `string`

  - `symbol` (ES2015)

  - `null`

  - `underfined`

```ts
let name = "mark";

name.toString();
```

- `literal` ê°’ìœ¼ë¡œ `primitive` íƒ€ì…ì˜ ì„œë¸Œ íƒ€ì…ì„ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```ts
true; //  ì „ì²´ boolean type ì¤‘ì— sub-type ì¸ true

("hello"); // ì „ì²´ string type ì¤‘ì— sub-type ì¸ 'hello'

3.14; // ì „ì²´ number type ì¤‘ì— sub-type ì¸ 3.14

null;

underfined;
```

- JS ì—ì„œëŠ” ë˜í¼ ê°í˜ë¡œ í•´ì„œ ë§Œë“¤ì–´ì¤Œ

```ts
new Boolean(false); // typeof new Boolean(false) : 'object'

new String("world"); // typeof new String('world') : 'object'

new Number(42); // typeof new Number (42) : 'object'
```

### Type Casing

> from ê³µì‹ ì‚¬ì´íŠ¸ : [(https://www.typescriptlang.org/)](https://www.typescriptlang.org/){:target="\_blank"}

- The code primitive types in TypeScript are all lowecase. (TypeScriptì˜ í•µì‹¬ primitive types ì€ ëª¨ë‘ ì†Œë¬¸ì ì…ë‹ˆë‹¤)

- It can be tempting to think that the types` Number, String, Boolean, Symbol, or Object` are the same as the lowercase version recommended above. (Number, String, Boolean, Symbol ë˜ëŠ” Object ìœ í˜•ì´ ìœ„ì—ì„œ ê¶Œì¥í•œ ì†Œë¬¸ì ë²„ì „ê³¼ ë™ì¼í•˜ë‹¤ê³  í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.)

- These types `do not refer` to the language `primitives` however, and almost never should be used as a type. (ê·¸ëŸ¬ë‚˜ ì´ëŸ¬í•œ ìœ í˜•ì€ primitives ë¥¼ ë‚˜íƒ€ë‚´ì§€ ì•Šìœ¼ë©°, íƒ€ì…ìœ¼ë¡œ ì‚¬ìš©í•´ì„œëŠ” ì•ˆë©ë‹ˆë‹¤)

```ts
function reverse(s: String): String {
  // ëŒ€ë¬¸ìë¡œ íƒ€ì… ì‚¬ìš©í•˜ë©´ ì•ˆë©!!
  return s.split("").reverse().join("");
}

reverse("hello world");
```

- Instead, use the types number, string, boolean, object and symbol

```ts
function reverse(s: string): string {
  // ì†Œë¬¸ìë¡œ ì‚¬ìš©
  return s.split("").reverse().join("");
}

reverse("hello world");
```

ğŸ”¹ ë³µìŠµ!! Project í´ë”ì— TS ì‹¤ìŠµí™˜ê²½ ì„¤ì¹˜

1. Create proper folder

2. `npm init -y` // í”„ë¡œì íŠ¸ ì§€ì—­ì— node.js ì„¤ì¹˜

3. `npm install typescript -D` // TS -devDependencies ëª¨ë“œë¡œ ì„¤ì¹˜

4. `npx tsc --init` // root ê²½ë¡œì— tsconfig.json íŒŒì¼ ìƒì„±

5. `npx tsc` // ì»´íŒŒì¼ ì‹¤í–‰

6. `node íŒŒì¼ëª….js` // ì»´íŒŒì¼ í•œ js íŒŒì¼ ì‹¤í–‰ ëª…ë ¹

## 3.boolean

```ts
let isDone: boolean = false; // ì†Œë¬¸ì ê°€ëŠ¥

isDone = true;



console.log(typeof isDone); // `boolean`


------------------------------------------------


let isOk: Boolean = true; // ë˜ë„ë¡ì´ë©´ ì†Œë¬¸ìë¥¼ ì‚¬ìš©í•´ì•¼ í•¨


// `boolean` is a primitive, but 'Boolean' is a warpper object. Prefer using `boolean` when possible.
let isnotOk: boolean = new Boolean(true); // error
```

## 4.number

- JSì™€ ê°™ì´, TS ì˜ ëª¨ë“  ìˆ«ìëŠ” ë¶€ë™ ì†Œìˆ˜ì  ê°’ ì…ë‹ˆë‹¤.

- TSëŠ” 16ì§„ìˆ˜ ë° 10ì§„ìˆ˜ literal ì™¸ì—ë„ ECMAScript 2015ì—ì„œ ë„ì…ëœ 2ì§„ìˆ˜ ë° 8ì§„ìˆ˜ë¥¼ ì§€ì›í•©ë‹ˆë‹¤.

- NaN

- 1_000_000 ê³¼ ê°™ì€ í‘œê¸°ë„ ê°€ëŠ¥í•©ë‹ˆë‹¤.

```ts
let decimal: number = 6; // ì‹­ì§„ìˆ˜

let hex: number = 0xf000d; // 16ì§„ìˆ˜

let binary: number = 0b1010; // 2ì§„ìˆ˜

let octal: number = 0o744; // 8ì§„ìˆ˜

let notANumber: number = NaN;

let underscoreNum: number = 1_000_000;
```

## 5.string

- ë‹¤ë¥¸ì–¸ì–´ì™€ ë§ˆì°¬ê°€ì§€ë¡œ ì´ í…ìŠ¤íŠ¸ í˜•ì‹ì„ ì°¸ì¡°í•˜ê¸° ìœ„í•´ `string` (backtick)í˜•ì‹ì„ ì‚¬ìš©í•©ë‹ˆë‹¤

- JS ì™€ ë§ˆì°¬ê°€ì§€ë¡œ, TS ëŠ” ë¬¸ìì—´ ë°ì´í„°ë¥¼ ë‘˜ëŸ¬ì‹¸ê¸° ìœ„í•´ ""(quotaion mark), ''(apostrophe)

```ts
let myName: string = "Jacob";

myName = "Emma";
```

### Template String

- í–‰ì— ê±¸ì³ ìˆê±°ë‚˜, í‘œí˜„ì‹ì„ ë„£ìš¸ ìˆ˜ ìˆëŠ” ë¬¸ìì—´

- ì´ ë¬¸ìì—´ì€ backtick(=backquote) ê¸°í˜¸ì— ë‘˜ëŸ¬ ìŒ“ì—¬ ìˆìŠµë‹ˆë‹¤

- í¬í•¨ëœ í‘œí˜„ì‹ì€ `${expr}` ì™€ ê°™ì€ í˜•íƒœë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.

## 6.symbol

- ECMAScript 2015ì˜ symbol ì…ë‹ˆë‹¤.

- new Symbol ë¡œ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.

- Symbol ì„ í•¨ìˆ˜ë¡œ ì‚¬ìš©í•´ì„œ symbol íƒ€ì…ì„ ë§Œë“¤ì–´ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```ts
// console.log(Symbol('foo')) // error ë°œìƒ -> Symbol only refers to a type. but is being used as a value here.

// ì„ì‹œë¡œ symbol ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ tsconfig.json ì—ì„œ "lib": ["ES2015", "DOM"], ì—ì„œ ì¡°ì ˆ í•œë‹¤ìŒì— ì„ì‹œë¡œ ì‚¬ìš©ê°€ëŠ¥í•˜ê²Œ ì¡°ì ˆ

console.log(Symbol("foo") === Symbol("foo")); // false ì¶œë ¥ -> ë‹¤ë¥¸ ë©”ëª¨ë¦¬ë¡œ ë‚˜ì˜´
```

### symbol ì´ ì‚¬ìš©ë˜ëŠ” ê²½ìš°

- í”„ë¦¬ë¯¸í‹°ë¸Œ íƒ€ì…ì˜ ê°’ì„ ë‹´ì•„ì„œ ì‚¬ìš©í•©ë‹ˆë‹¤.

- ê³ ìœ í•˜ê³  ìˆ˜ì •ë¶ˆê°€ëŠ¥í•œ ê°’ìœ¼ë¡œ ë§Œë“¤ì–´ì¤ë‹ˆë‹¤.

- ê·¸ë˜ì„œ ì£¼ë¡œ ì ‘ê·¼ì„ ì œì–´í•˜ëŠ”ë° ì“°ëŠ” ê²½ìš°ê°€ ë§ì•˜ìŠµë‹ˆë‹¤.

## 7.undefined & null

- In TypeScript, both underfined and null actially have their types named underfined and null respectively. (TypeScriptì—ì„œ undefined ì™€ nul ì€ ì‹¤ì œë¡œ ê°ê° undefined ë° null ì´ë¼ëŠ” íƒ€ì…ì„ ê°€ì§‘ë‹ˆë‹¤.)

- Much like void, they're not extremely useful on their own: (voidì™€ ë§ˆì°¬ê°€ì§€ë¡œ, ê·¸ ìì²´ë¡œëŠ” ê·¸ë‹¤ì§€ ìœ ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.)

- ë‘˜ë‹¤ ì†Œë¬¸ìë§Œ ì†ì¬í•©ë‹ˆë‹¤.

```ts
// ì´ ë³€ìˆ˜ë“¤ì— í• ë‹¹í•  ìˆ˜ ìˆëŠ” ê²ƒë“¤ì€ ê±°ì˜ ì—†ë‹¤.

let u: underfined = undefined;
let n: null = null;
```

### underfined & null are subtypes of all other types.

- ì„¤ì •ì„ í•˜ì§€ ì•Šìœ¼ë©´ ê·¸ë ‡ìŠµë‹ˆë‹¤.

- `numberì—` `null` ë˜ëŠ” `underfinedë¥¼` í• ë‹¹í•  ìˆ˜ ìˆë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤.

- í•˜ì§€ë§Œ, ì»´íŒŒì¼ ì˜µì…˜ì—ì„œ `--strictNullChecks` ì‚¬ìš©í•˜ë©´, `null` ê³¼ `undefined` ëŠ” `void` ë‚˜ ìê¸° ìì‹ ë“¤ì—ê²Œ ë§Œ í• ë‹¹í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

  - ì´ ê²½ìš°, `null` ê³¼ `undefined` ë¥¼ í• ë‹¹í•  ìˆ˜ ìˆê²Œ í•˜ë ¤ë©´, `union type` ì„ ì´ìš©í•´ì•¼ í•©ë‹ˆë‹¤.

```ts
let Myname: string = null; // ì´ë ‡ê²Œ ì“°ë©´ ì•ˆë¨
let age: number = underfined;

// strickNulllCjecks => true
// Type `null` is not assignable to type `string`.
let name: string = null;
X;

// null => null || voidm underfined => undefined || void
// Type `null` is not assignable to type 'underfined'
let u: undefined = null; // (X)

let v: void = undefined; // (O)

let union: string | null | undefined = "str"; // êµì§‘í•©ì¸ | ì„ ì‚¬ìš©í•´ì•¼ í•¨
```

### null in JavaScript

- null ì´ë¼ëŠ” ê°’ìœ¼ë¡œ í• ë‹¹ëœ ê²ƒì„ null ì´ë¼ê³  í•©ë‹ˆë‹¤.

- ë¬´ì–¸ê°€ê°€ ìˆëŠ”ë°, ì‚¬ìš©í•  ì¤€ë¹„ê°€ ëœ ëœ ìƒíƒœ.

- null ì´ë¼ëŠ” íƒ€ì…ì€ null ì´ë¼ëŠ” ê°’ë§Œ ê°€ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

- **ëŸ°íƒ€ì„ì—ì„œ typeof ì—°ì‚°ìë¥¼ ì´ìš©í•´ì„œ ì•Œì•„ë‚´ë©´, object ì…ë‹ˆë‹¤**

```ts
let n: null = null;

console.log(n); // null
console.log(typeof n); // object
```

### undefined in JavaScript

- ê°’ì„ í• ë‹¹í•˜ì§€ ì•Šì€ ë³€ìˆ˜ëŠ” undefined ë¼ëŠ” ê°’ì„ ê°€ì§‘ë‹ˆë‹¤.

- ë¬´ì–¸ê°€ê°€ ì•„ì˜ˆ ì¤€ë¹„ê°€ ì•ˆëœ ìƒíƒœ

- object ì˜ propertyê°€ ì—†ì„ ë•Œë„ undefined ì…ë‹ˆë‹¤.

- **ëŸ°íƒ€ì„ì—ì„œ typeof ì—°ì‚°ìë¥¼ ì´ìš©í•´ì„œ ì•Œì•„ë‚´ë©´, undefined ì…ë‹ˆë‹¤.**

```ts
let u: undefined = undefinde;

console.log(u); // undefined
console.log(typeof u); // undefined
```

## 8.object

- a type that represents the **non-promitive type** ("promitive type ì´ ì•„ë‹Œê²ƒ" ì„ ë‚˜íƒ€ë‚´ê³  ì‹¶ì„ ë•Œ ì‚¬ìš©í•˜ëŠ” íƒ€ì…)

- non-primitive type : **not** number, string, boolean, bigint, symbol, null, or undefined

```ts
// create by object literal
const person1 = { name: "Jacob", age: 80 };

// person1 is not "object" type.
// person1 is "{name: string, age: number}" type.

// create by Object.create
const person2 = Object.create({ name: "Jacob", age: 80 });

const person3 = Object.create(80); // ì´ëŸ°ê²ƒì„ ë§‰ê¸° ìœ„í•´ object type ì´ ì¡´ì¬í•˜ëŠ”ê²ƒì„

// object ì‚¬ìš© ì˜ˆì œ

let obj: object = {};

obj = { name: "Jacob" };

obj = [{ name: "Jacob" }];

obj = 80; // Error

obj = "Jacob"; // Error

obj = true; // Error

obj = 100n; // Error

obj = Symbol(); // Error

obj = null; // Error

obj = undefined; // Error

declare function create(o: object | null): void; // premitive type ì„ ë°›ì§€ ì•ŠëŠ”ê²½ìš°ì— ì‚¬ìš©

create({ prop: 0 });

create(null);

create(42); // Error

create("string"); // Error

create(false); // Error

create(undefined); // Error

// Object.create
Object.create(0); // Error
```

## 9.Array

- ì›ë˜ JavaScript ì—ì„œ array ëŠ” ê°ì²´ì…ë‹ˆë‹¤.

- ì‚¬ìš©ë°©ë²•

  - Array<íƒ€ì…>

  - íƒ€ì…[] -> ì´ ë°©ì‹ì„ ì£¼ë¡œ ì‚¬ìš©í•¨!!

```ts
// Array ì„ ì–¸ë°©ì‹ì€ 2ê°€ì§€ê°€ ìˆìŒ ê·¼ë°, ì²«ë²ˆì§¸ ë°©ì‹ì„ ì‚¬ìš©í•˜ëŠ”ê²ƒì„ ì¶”ì²œí•¨.
let list1: number[] = [1, 2, 3];

let list2: Array<number> = [1, 2, 3];

let list3: (number | string)[] = [1, 2, 3, "4"]; // array ì•ˆì— str ì„ ë„£ìœ¼ë ¤ë©´ union type | ì„ ì¨ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ
```

## 10.Tuple

```ts
// tuple
let x: [string, number];

x = ["hello", 80]; // í•­ìƒ ìˆœì„œë„ ë§ì•„ì•¼ ë˜ê³ , type ë„ ë§ì•„ì•¼ ë˜ê³  index ê¸¸ì´ë„ ë§ì•„ì•¼ ë¨

x = [10, "Jacob"]; // Error;

x[3] = "world"; // index ê¸¸ì´ê°€ ë§ì§€ ì•Šì•„ì„œ Error

const person: [string, number] = ["Jacob", 80];

const [first, second, third] = person; // deconstruction ë¶„í•´ í• ë‹¹ , index number Error
```

## 11.any

- ì–´ë–¤ íƒ€ì…ì´ì–´ë„ ìƒê´€ì—†ëŠ” íƒ€ì…ì…ë‹ˆë‹¤.

- ì´ê±¸ ìµœëŒ€í•œ ì“°ì§€ ì•ŠëŠ”ê²Œ í•µì‹¬ì…ë‹ˆë‹¤.

- ì™œëƒí•˜ë©´ ì»´íŒŒì¼ íƒ€ì„ì— íƒ€ì… ì²´í¬ê°€ ì •ìƒì ìœ¼ë¡œ ì´ë¤„ì§€ì§€ ì•Šê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

- ê·¸ë˜ì„œ ì»´íŒŒì¼ ì˜µì…˜ ì¤‘ì—ëŠ” any ë¥¼ ì¨ì•¼ í•˜ëŠ”ë° ì“°ì§€ ì•Šìœ¼ë©´ ì˜¤ë¥˜ë¥¼ ë±‰ë„ë¡ í•˜ëŠ” ì˜µì…˜ë„ ìˆìŠµë‹ˆë‹¤.

  - nolmiplicitAny

- The any will continue to progagate through your objects: (**anyëŠ” ê³„ì†í•´ì„œ ê°œì²´ë¥¼ í†µí•´ ì „íŒŒë©ë‹ˆë‹¤.**)

- After all, remember that all the convenience ofany comes at the cost of losing type safely. (**ê²°êµ­, ëª¨ë“  í¸ì˜ëŠ” íƒ€ì… ì•ˆì •ì„±ì„ ìƒëŠ” ëŒ€ê°€ë¡œ ì˜¨ë‹¤ëŠ” ê²ƒì„ ê¸°ì–µí•˜ì‹­ì‹œì˜¤**)

- Type safety is one of the main motivations for using TypeScript and you should try to avoid using any when not necessary. (**íƒ€ì… ì•ˆì •ì„±ì€ TypeScript ë¥¼ ì‚¬ìš©í•˜ëŠ” ì£¼ìš” ë™ê¸° ì¤‘ í•˜ë‚˜ì´ë©° í•„ìš”í•˜ì§€ ì•Šì€ ê²½ìš°ì—ëŠ” any ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šë„ë¡ í•´ì•¼ í•©ë‹ˆë‹¤.**)

```ts
// any : ì•„ë¬´ê²ƒë„ ëª¨ë¥¸ ìƒíƒœì—ì„œ ì–´ë–¤ ê²ƒì´ë“  í•  ìˆ˜ ìˆë‹¤ ë¼ëŠ” ëœ»ì„
function returnAny(message: any): any {
  console.log(message);
}

const any1 = returnAny("ë¦¬í„´ì€ ì•„ë¬´ê±°ë‚˜ ë‹¤ ë¨");

any1.toString();

// ì˜ˆì‹œ

let looselyTyped: any = {};

const d = looselyTyped.a.b.c.d; // ì´ë ‡ê²Œ ë§‰ ì¨ë„ error ê°€ ë‚˜ì§€ ì•ŠìŒ

function leakingAny(obj: any) {
  const a = obj.num;
  const b = a + 1;
  return b;
}

const c = leakingAny({ num: 0 });
c.indexOf("0");
```

## 12.unknown

- We my need to describe the type of variables that we do not know when we are wrting an application. (**ì‘ìš© í”„ë¡œê·¸ë¨ì„ ì¥ì„±í•  ë•Œ ëª¨ë¥´ëŠ” ë³€ìˆ˜ì˜ íƒ€ì…ì„ ë¬˜ì‚¬í•´ì•¼ í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.**)

- These values my come from dynamic contect - e.g from the user - or we may want to intentionally accept all balues in our API. (**ì´ëŸ¬í•œ ê°’ì€ ë™ì  ì½˜í…ì¸  (ì˜ˆ: ì‚¬ìš©ìë¡œë¶€í„°, ë˜ëŠ” ìš°ë¦¬ APIì˜ ëª¨ë“  ê°’ìœ¼ ã„¹ì˜ë„ì ìœ¼ë¡œ ìˆ˜ë½í•˜ê¸°ë¥¼ ì›í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.**))

- In these cases, we want yo provide a type that tells the compiler and future readers that this variable could be anything, so we give it the unknown type. (**ì´ ê²½ìš°, ì»´íŒŒì¼ëŸ¬ì™€ ë¯¸ë˜ì˜ ì½”ë“œë¥¼ ì½ëŠ” ì‚¬ëŒì—ê²Œ ì´ ë³€ìˆ˜ê°€ ë¬´ì—‡ì´ë“  ë  ìˆ˜ ìˆì„ì„ ì•Œë ¤ì£¼ëŠ” íƒ€ì…ì„ ì œê³µí•˜ê¸°ë¥¼ ì›í•˜ë¯€ë¡œ unknown íƒ€ì…ì„ ì œê³µí•©ë‹ˆë‹¤.**)

### unknown ì •ë¦¬

- TypeScript 3.0 ë²„ì „ë¶€í„° ì§€ì›

- anyì™€ ì§ìœ¼ë¡œ any ë³´ë‹¤ Type-safe í•œ íƒ€ì…

  - anyì™€ ê°™ì´ ì•„ë¬´ê±°ë‚˜ í• ë‹¹í•  ìˆ˜ ìˆë‹¤

  - ì»´íŒŒì¼ëŸ¬ê°€ íƒ€ì…ì„ ì¶”ë¡ í•  ìˆ˜ ìˆê²Œ ë” íƒ€ì…ì˜ ìœ í˜•ì„ ì¢íˆê±°ë‚˜

  - íƒ€ì…ì„ í™•ì •í•´ì£¼ì§€ ì•Šìœ¼ë©´ ë‹¤ë¥¸ ê³³ì— í• ë‹¹ í•  ìˆ˜ ì—†ê³ , ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤.

- unknown íƒ€ì…ì„ ì‚¬ìš©í•˜ë©´ runtime errorë¥¼ ì¤„ì¼ ìˆ˜ ìˆì„ ê²ƒ ê°™ë‹¤.

  - ì‚¬ìš© ì „ì— ë°ì´í„°ì˜ ì¼ë¶€ ìœ í˜•ì˜ ê²€ì‚¬ë¥¼ ìˆ˜í–‰í•´ì•¼ í•¨ì„ ì•Œë¦¬ëŠ” APIì— ì‚¬ìš©í•  ìˆ˜ ìˆì„ ê²ƒ ê°™ë‹¤.

```ts
declare const maybe: unknown;

const aNumber: number = maybe;

if (maybe === true) {
  // unknown ì´ ì´ì œëŠ” boolean í˜•íƒœë¡œëŠ” ë°›ì„ ìˆ˜ ìˆê²Œ ë¨
  const aBoolean: boolean = maybe; // ì •ìƒ
  const aString: string = maybe; // str ë¡œëŠ” ë°›ì„ ìˆ˜ ì—†ê¸° ë•Œë¬¸ì— error
}

if (typeof maybe === "string") {
  // unknown ì´ ì´ì œëŠ” str í˜•íƒœë¡œ ë°›ì„ ìˆ˜ ìˆê²Œ ë¨
  const aString: string = maybe; // ì •ìƒ
  const aBoolean: boolean = maybe; // ë”ì´ìƒ maybeê°€ boolean í˜•íƒœê°€ ì•„ë‹ˆê¸° ë•Œë¬¸ì— error ì„
}
```

## 13.never

- ì¼ë°˜ì ìœ¼ë¡œ return ì— ì‚¬ìš©ë©ë‹ˆë‹¤

- never íƒ€ì…ì€ ëª¨ë“  íƒ€ì…ì˜ subtype ì´ë©°, ëª¨ë“  íƒ€ì…ì— í• ë‹¹ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

- í•˜ì§€ë§Œ, never ì—ëŠ” ê·¸ ì–´ë–¤ ê²ƒë„ í• ë‹¹í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.

- any ì¡°ì°¨ë„ never ì—ê²Œ í• ë‹¹ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.

- ì˜ëª»ëœ íƒ€ì…ì„ ë„£ëŠ” ì‹¤ìˆ˜ë¥¼ ë§‰ê³ ì í•  ë•Œ ì‚¬ìš©í•˜ê¸°ë„ í•©ë‹ˆë‹¤.

```ts
// ì¼ë°˜ì ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” never ì‚¬ìš©ì˜ ì˜ˆì œ

function error(message: string): never {
  throw new Error(message); // ì–´ë– í•œ í˜•íƒœë„ return ë˜ì§€ ì•ŠëŠ” ë‹¤ëŠ”ê²ƒ
}

function fail() {
  return error("failed");
}

function infiniteLoop(): never {
  while (true) {}
}

// ìì£¼ ì‚¬ìš©ë˜ëŠ” ì˜ˆì œ

let a: string = "hello";

if (typeof a !== "string") {
  a; // aê°€ never ê°€ ê°„ì£¼ ë¨ì— ë”°ë¼ ì‚¬ì „ì— ì˜ëª»ëœ ì‹¤ìˆ˜ë¥¼ ë§‰ì„ ìˆ˜ ìˆìŒ
}

declare const b: string | number;

if (typeof b !== "string") {
  b; // b ê°€ str ì´ ì•„ë‹ˆê¸° ë•Œë¬¸ì— number ë¡œ ë¨
}

type Indexable<T> = T extends string ? T & { [index: string]: any } : never; // ì¡°ê±´ë¶€ íƒ€ì…:  T ê°€ ë§Œì•½ì—  string any ë¡œ ê°€ê³  ì•„ë‹ˆë©´ never ê°€ ëœ¨ê²Œ ë¨

type ObjectIndexable = Indexable<{}>;

const b: Indexable<{}> = ""; // error ë°œìƒ ìœ„ì—ì„œ neverë¡œ ë¬ê¸° ë•Œë¬¸ì— ì•ˆë¨
```

## 14.void

- ì–´ë–¤ íƒ€ì…ë„ ê°€ì§€ì§€ ì•ŠëŠ” ë¹ˆ ìƒíƒœì¸ê²ƒì„ ë§í•©ë‹ˆë‹¤

- ì†Œë¬¸ìë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤

- ê°’ì„ ë°˜í™˜ í•˜ì§€ ì•Šì€ ì¦‰, undefined ë¥¼ return í–ˆë‹¤ê³  ë³´ë©´ ë©ë‹ˆë‹¤

- ë‹¤ë¥¸ì–¸ì–´ (Java ë“±)ì—ì„œ ë§ì´ ì“°ê¸° ë•Œë¬¸ì—, ê·¸ëƒ¥ ìš©ì–´ë§Œ ê°€ì ¸ ì™”ë‹¤ê³  ë³´ë©´ë¨ ì™œëƒë©´ JS, TS ì—ëŠ” undefined ê°€ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤

```ts
function returnVoid(message: string) {
  // ì•„ë¬´ê²ƒë„ return í•˜ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì— void ê°€ ë¨
  console.log(message);
  return undefined; // void ì— ìœ ì¼í•˜ê²Œ return í•  ìˆ˜ ìˆëŠ”ê²ƒì€ undefined ë¿ì´ë‹¤.
}

const r = returnVoid("ë¦¬í„´ì´ ì—†ë‹¤.");
```

## Reference

- TypeScript - [https://www.typescriptlang.org/](https://www.typescriptlang.org/){:target="\_blank"}

- HEROPY Tech - [https://heropy.blog/2020/01/27/typescript/](https://heropy.blog/2020/01/27/typescript/){:target="\_blank"}
